#!/usr/bin/env ruby

require "trollop"
require "directory_monitor"

# Define the strings we display to the user for version identification and the
# help message.

ProgName = File.basename($PROGRAM_NAME, File.extname($PROGRAM_NAME)) 
Version = "#{ProgName} (#{DirectoryMonitor::VERSION})" 
Banner = <<-eos
  #{Version} -- Watch a directory for changes
  Synopsis
      Executes a shell-command when any files in the current directory tree
      change. If the command contains a double-percent, %%, it is replaced
      with a space separated list of path names of the changed files. When
      used with the --loop option, the command is executed mutiple times,
      once each for each file that changed and %% is replaced with just one
      path name on each execution.

  Examples
      watch -cld 10 \"echo File %% has changed\"
      # Every 10 seconds, display each changed file on a separate line.
      
      watch -s "\\.rb|\\.yaml" rake
      # Every 5 seconds, run a rake task if any ruby or Yaml files change.

  Usage
      #{ProgName} [-cDfhlvV] [-d <float>] [-st <str>] <shell-command>
eos

# Use trollop to handle all our options switches and verify we have some sort
# of shell-command specified on the command-line.

opts = Trollop::options do
  version "#{Version}"
  banner Banner.gsub(/^#{Banner[/^ +/, 0]}/, "")
  opt :suffix,  "Regex to select the files being watched",    :default => ".*"
  opt :delay,   "Seconds to sleep between watches",           :default => 5.0
  opt :cascade, "Let shell-command trigger next watch"
  opt :loop,    "Use separate command for each changed file"
  opt :force,   "Force command at first, on all watched files"
  opt :token,   "Use instead of %%, for name substitution",   :default => "%%"
  opt :verbose, "Log status information to standard output",  :short => "V"
  opt :debug,   "Print debugging information and exit",       :short => "D"
end

Trollop::die "shell command is required" if ARGV.empty?
opts[:shell_command] = ARGV.join(" ")

# If we have the debug flag set, display everything we've extracted from the
# command-line and exit.

if opts[:debug]
  puts "#{ProgName} debug information"
  [ :suffix, :delay, :cascade, :loop,
    :force,  :token, :verbose, :shell_command ].each do |option|
    puts "  #{option.to_s}: #{opts[option]}"
  end
  exit
end

# We're ready to do the real work, now. Setup a directory monitor with the
# appropriate settings and use it to construct the shell commands.

dm = DirectoryMonitor::DirectoryMonitor.new(opts[:suffix], opts[:delay])
dm.on_change(opts[:loop], opts[:force], opts[:cascade]) do |*changed|
  shell_cmd = "#{opts[:shell_command].sub(opts[:token], changed.join(' '))}"
  puts shell_cmd if opts[:verbose]
  system(shell_cmd, out: $stdout, err: $stderr)
end

